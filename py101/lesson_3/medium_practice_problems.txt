Question 1

for count in range(1,11):
    print("-" * count + "The Flintstones Rock!")

for count in range(1,11):
print(f'{"-" * count}The Flintstones Rock!')

Question 2

def factors(number):
    divisor = number
    result = []
    while divisor > 0:
        if number % divisor == 0:
            result.append(number // divisor)
        divisor -= 1
    return result

The purpose of number % == 0 is to check whether or not the divisor is a factor of number.
If number % divisor = 0 than number % divisor will return True and therefore run the if
code block. 

Question 3

The key difference is that the first function mutates the original list (buffer). 
The second function does not. The second function creates a copy of the original list and changes
made to the list do not affect the oirignal list. If we use the second function and then print(buffer)
it will print out the original values of the list. The second function still returns a list with the
changes to the list. 

Question 4

print(0.3 + 0.6) #output ==> 0.9
print(0.3 + 0.6 == 0.9) #output ==> True

#LS solution 

In this case the output was 0.899999999 and False. This is because python uses floating point
numbers for all numeric operations. They lack precision. One way around the problem is to use the math.isclose
function:

import math

print(0.3 + 0.6)
print(math.isclose(0.3 + 0.6 == 0.9))


Question 5 + Bonus Question 

I dont think this code will raise an error because 'nan' cannot
be float type. 

#LS solution
The output is False. nan -- not a number is a special numeric value that indicates
that an operation that was intended to return a number failed. 
Python doesn't let you use == to determine whether a value is nan. 

#LS solution --> Bonus question 

To test whether a value is nan, you can use the math.isnan() function. 

import math

nan_value = float('nan')
print(math.isnan(nan_value))


Question 6 

This should output 34

Question 7

Yes the family's data did get ransacked. This is because dictionaries are
a mutable data type. Therefore when you pass a dictionary into a function
and start making changes to the dictionary, you are making changes to the
dictionary rather than a copy of the dictionary. 

Question 8

This code returns paper.

To represent the different layers I will label the rps functions as rps1-4
from left to right. 

rps1 == rps(rps2, "rock")
rps2 == rps(rps3, rps4)
rps3 == rps("rock", "paper")
rps4 == rps("rock", "scissor") 

rps1 == rps("paper", "rock") #output ==> "paper"
rps2 == rps("paper", "rock") #output ==> "paper"
rps3 == rps("rock, "paper")#output ==> "paper"
rps4 == rps("rock", "scissors") #output ==> "rock"

Therefore the final output is 'paper'

Question 9

This will return False. foo() always returns "yes".
If we pass foo() into bar(), param will never be "no". Because of the and
operator, we don't even have to look at the rest of the equation to know that this
function will return False. 

Question 10 

This should output True. If we use the idea of internining from the 
question, we can assume that a = 42 and b = 42 point to the same object.
We then set c to point to the same object as a. So I predict that this will
print True as they are all pointing to the same object. 

#note from LS
There is a predefined range of integers (-5 - 256) for which memory locations are pre-assigned.
Integers referenced within this range, python will consistantly point to the same spot. 
This strategy enhances efficiencey since these particular numbers are commonly utilized
in mnay programming scenarios.
When working with integers outside this range, python doesn't assure that it will consistently point to 
the same memory address for identical values across different variables. 